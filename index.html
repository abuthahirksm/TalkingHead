<!DOCTYPE html>
<html>

<head>
  <title>Talking Head</title>

  <meta charset="utf-8">
  <meta
    content="width=device-width, height=device-height, minimum-scale=1.0, maximum-scale=1.0, initial-scale=1.0, user-scalable=no, interactive-widget=resizes-content"
    name="viewport">
  <link rel="icon" type="image/jpg" href="favicon.jpg">

  <style>
    html {
      width: 100%;
      height: 100%;
      height: -webkit-fill-available;
      font-size: 14px;
    }

    /* Color themes */
    :root,
    .theme-dark {
      --colorBody: #88ccff;
      --colorBackground: #202020;
      --colorPanel: rgba(32, 32, 32, 0.98);
      --colorBorderPassive: rgba(136, 204, 255, 0.6);
      --colorBorderActive: #88ccff;
      --colorUserText: #88ccff;
      --colorSystemText: #cc77ff;
      --colorToolbarPassive: rgba(136, 204, 255, 0.6);
      --colorToolbarPassive2: rgba(136, 204, 255, 0.3);
      --colorToolbarActive: #88ccff;
      --widthLabel: 5rem;
      --colorGlow: #88ccff;
    }


    body {
      width: 100%;
      height: 100%;
      min-height: 100vh;
      min-height: -webkit-fill-available;
      margin: 0;
      padding: 0;
      background-color: var(--colorBackground);
      color: var(--colorBody);
      overflow: hidden;
      text-align: left;
      touch-action: manipulation;
      font-family: "SansRegular", sans-serif;
      font-size: 1.4rem;
      line-height: 1.4rem;
      scrollbar-color: var(--colorToolbarPassive) transparent;
      scrollbar-width: 20px;
      scrollbar-height: 20px;

      background-image: url(./images/bg1.gif);
      background-size: cover;
      background-position: center;
    }


    .glow {
      box-shadow: 0 0 25px 5px var(--colorGlow);
    }

    .theme-light .glow {
      box-shadow: none;
    }

    /* Main */
    #main {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: transparent;
    }



    #avatar,
    #view {
      position: absolute;
      opacity: 0;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: auto;
      overflow: hidden;
      border-radius: inherit;
    }



    #avatar {
      width: 40%;
      top: unset;
      bottom: -10%;
      height: 80%;
    }

    #view {
      background-image: url(./images/bg.gif);
      background-repeat: no-repeat;
      background-position: center center;
      background-size: cover;
    }


    /* Loading */
    #loading {
      display: block;
      position: absolute;
      top: 6px;
      left: 6px;
      width: 300px;
      height: 30px;
      pointer-events: none;
      font-size: 1rem;
      background-color: transparent;
    }

    #loading-back,
    #loading-top {
      display: block;
      position: absolute;
      top: 10px;
      left: 20px;
      bottom: 10px;
      width: 95px;
    }

    #loading-back {
      background: repeating-linear-gradient(to right, var(--colorToolbarPassive2),
          var(--colorToolbarPassive) 5px,
          transparent 5px,
          transparent 10px);
    }

    #loading-top {
      clip-path: inset(0 100% 0 0);
      background: repeating-linear-gradient(to right, var(--colorBody),
          var(--colorBody) 5px,
          transparent 5px,
          transparent 10px);
    }

    #loading-value {
      display: block;
      position: absolute;
      top: 0;
      left: 125px;
      bottom: 0;
      right: 0;
      line-height: 30px;
      text-align: left;
      font-size: 1.4rem;
      font-family: "SansRegularCondensed";
    }



    .grayed {
      opacity: 0.3;
    }

    .noselect {
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      -webkit-user-select: none;
    }

    .nodrag {
      -webkit-user-drag: none;
      -khtml-user-drag: none;
      -moz-user-drag: none;
      -o-user-drag: none;
      -ms-user-drag: none;
      user-drag: none;
    }

    .disabled {
      opacity: 0.5;
      cursor: default;
      pointer-events: none;
    }

    .hidden {
      display: none;
    }

    .starttransparent {
      opacity: 0;
    }

    /* blinking */
    @-webkit-keyframes blinking {
      to {
        visibility: hidden
      }
    }

    @keyframes blinking {
      to {
        visibility: hidden
      }
    }

    .blink>:not(div):not(ol):not(ul):not(pre):last-child:after,
    .blink>ol:last-child li:last-child:after,
    .blink>pre:last-child code:after,
    .blink>ul:last-child li:last-child:after {
      -webkit-animation: blinking 1s steps(5, start) infinite;
      animation: blinking 1s steps(5, start) infinite;
      content: "▋";
      position: absolute;
      margin: 0 0 0 .25rem;
      padding: 0;
      vertical-align: baseline;
      white-space: nowrap;
      width: 0;
      overflow: visible;
    }


    /* Fonts */
    @font-face {
      font-family: "SansRegular";
      src: url("./fonts/FiraSansCondensed-Regular.ttf") format('truetype');
    }

    @font-face {
      font-family: "SansItalic";
      src: url("./fonts/FiraSansCondensed-Italic.ttf") format('truetype');
    }

    @font-face {
      font-family: "SansBold";
      src: url("./fonts/FiraSansCondensed-Bold.ttf") format('truetype');
    }

    @font-face {
      font-family: "SansBoldItalic";
      src: url("./fonts/FiraSansCondensed-BoldItalic.ttf") format('truetype');
    }

    @font-face {
      font-family: "SansRegularCondensed";
      src: url("./fonts/FiraSansExtraCondensed-Regular.ttf") format('truetype');
    }

    @font-face {
      font-family: "SansBoldCondensed";
      src: url("./fonts/FiraSansExtraCondensed-Bold.ttf") format('truetype');
    }

    /* Layouts */
    #main.ratio-wide {
      width: min(96vw, 192vh, 1400px);
      height: min(48vw, 96vh, 700px);
    }

    /* 1:2 */
    #main.ratio-normal {
      width: min(96vw, 128vh, 1040px);
      height: min(72vw, 96vh, 780px);
    }

    /* 3:4 */
    #main.layout-full {
      width: 100%;
      height: 100%;
    }

    #main.layout-land #left {
      top: 0;
      left: 0;
      bottom: 38%;
      right: 50%;
    }

    #main.layout-port #left {
      top: 0;
      left: 0;
      bottom: 0;
      right: 60%;
    }

    #main.layout-full #left {
      top: 0;
      left: 0;
      bottom: 0;
      right: 0;
      margin: 0;
    }

    #main.layout-full #left .border {
      display: none;
    }

    #main.layout-land #right {
      top: 0;
      left: 50%;
      bottom: 0;
      right: 0;
    }

    #main.layout-port #right {
      top: 0;
      left: 40%;
      bottom: 30%;
      right: 0;
    }

    #main.layout-full #right {
      top: 10%;
      left: 45%;
      bottom: 30%;
      right: 5%;
      max-width: 800px;
    }

    #main.layout-land #bottom {
      top: 62%;
      left: 0;
      bottom: 0;
      right: 50%;
    }

    #main.layout-port #bottom {
      top: 70%;
      left: 40%;
      bottom: 0;
      right: 0;
    }

    #main.layout-full #bottom {
      top: 70%;
      left: 45%;
      bottom: 10%;
      right: 5%;
      max-width: 750px;
    }

    #main.presence-vr #left {
      box-shadow: none;
      background-color: transparent;
    }

    #main.presence-vr #view {
      display: none;
    }

    #main.presence-vr #left .border {
      display: none;
    }

    #main.presence-vr #avatar {
      bottom: -8px;
      left: -400px;
      right: -400px;
    }

    #main.layout-full #avatar {
      top: 0;
      left: 0;
      bottom: 0;
      right: 45%;
    }

    @media (max-width: 1000px) {

      #main.ratio-wide,
      #main.ratio-normal {
        width: 96vw;
        height: 90vh;
      }

      #main.layout-full {
        width: 100%;
        height: 100%;
      }

      #main.layout-land #left {
        top: 0;
        left: 0;
        bottom: 62%;
        right: 0;
      }

      #main.layout-port #left {
        top: 0;
        left: 0;
        bottom: 24%;
        right: 62%;
      }

      #main.layout-land #right {
        top: 38%;
        left: 0;
        bottom: 24%;
        right: 0;
      }

      #main.layout-port #right {
        top: 0;
        left: 38%;
        bottom: 24%;
        right: 0;
      }

      #main.layout-full #right {
        top: 0;
        left: 38%;
        bottom: 24%;
        right: 0;
        max-width: none;
      }

      #main.layout-land #bottom {
        top: 76%;
        left: 0;
        bottom: 0;
        right: 0;
      }

      #main.layout-port #bottom {
        top: 76%;
        left: 0;
        bottom: 0;
        right: 0;
      }

      #main.layout-full #bottom {
        top: 76%;
        left: 38%;
        bottom: 0;
        right: 0;
        max-width: none;
      }
    }
  </style>

  <script
    nomodule>alert("You browser doesn't seem to support modules. Use a modern browser to run Enterprise.");</script>
  <script src="https://d3js.org/d3.v6.min.js"></script>
  <script async src="https://cdn.jsdelivr.net/npm/es-module-shims@1.7.1/dist/es-module-shims.js"></script>
  <script type="importmap">
{ "imports":
  {
    "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js/+esm",
    "three/examples/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/",
    "dompurify": "https://cdn.jsdelivr.net/npm/dompurify@3.1.7/+esm",
    "marked": "https://cdn.jsdelivr.net/npm/marked@14.1.3/+esm"
  }
}
</script>
  <script
    src="https://cdn.jsdelivr.net/npm/microsoft-cognitiveservices-speech-sdk@latest/distrib/browser/microsoft.cognitiveservices.speech.sdk.bundle-min.js"></script>

  <script type="module">
    import { site } from './siteconfig.js'
    import { TalkingHead } from "./modules/talkinghead.mjs";
    import dompurify from 'dompurify';
    import { marked } from 'marked';

    var siteConfig = site;

    // API proxys
    const jwtEndpoint = "/app/jwt/get"; // Get JSON Web Token for Single Sign-On
    const openaiChatCompletionsProxy = "/openai/v1/chat/completions";
    const openaiModerationsProxy = "/openai/v1/moderations";
    const openaiAudioTranscriptionsProxy = "/openai/v1/audio/transcriptions";
    const geminiProxy = "/gemini/";
    const googleTTSProxy = "/gtts/";
    const elevenTTSProxy = [
      "wss://" + window.location.host + "/elevenlabs/",
      "/v1/text-to-speech/",
      "/stream-input?model_id=eleven_turbo_v2_5&output_format=pcm_22050"
    ];
    const microsoftTTSProxy = [
      "wss://" + window.location.host + "/mstts/",
      "/cognitiveservices/websocket/v1"
    ];
    const grokChatCompletionsProxy = "/grok/v1/chat/completions"; // Grok-beta
    const llamaChatCompletionsProxy = "/llama/v1/chat/completions"; // Local llama.cpp server proxy
    const localWhisperCppProxy = "/whisper/"; // Local whisper.cpp server proxy


    // Direct API endpoints
    const openaiChatCompletionsEndpoint = "https://api.openai.com/v1/chat/completions";
    const openaiModerationsEndpoint = "https://api.openai.com/v1/moderations";
    const openaiAudioTranscriptionsEndpoint = "https://api.openai.com/v1/audio/transcriptions";
    const geminiEndpoint = "https://generativelanguage.googleapis.com/v1beta/models/";
    const googleTTSEndpoint = "https://eu-texttospeech.googleapis.com/v1beta1/text:synthesize";
    const elevenTTSEndpoint = [
      "wss://api.elevenlabs.io/v1/text-to-speech/",
      "/stream-input?model_id=eleven_turbo_v2_5&output_format=pcm_22050"
    ];
    const microsoftTTSEndpoint = "wss://northeurope.tts.speech.microsoft.com/cognitiveservices/websocket/v1";
    const grokChatCompletionsEndpoint = "https://api.x.ai/v1/chat/completions";


    // I18n internationalization
    const i18n = {

      'fi': {
        'Avatar': 'Hahmo', 'Camera': 'Kamera', 'Audio': 'Ääni', 'Manuscript': 'Käsikirjoitus',
        'Emotion': 'Tunne', 'Neutral': 'Perus', 'Happy': 'Ilo', 'Angry': 'Viha', 'Sad': 'Suru',
        'Fear': 'Pelko', 'Disgust': 'Inho', 'Love': 'Rakkaus', 'Sleep': 'Uni', 'Pose': 'Asento',
        'Action': 'Toiminta', 'Frame': 'Rajaus', 'Full': 'Kokovartalo', 'Upper': 'Yläosa',
        'Head': 'Pää', 'Director': 'Ohjaus', 'Pause': 'Pysäytyskuva', 'Panning': 'Panorointi',
        'Slow-motion': 'Hidastus', 'Ambience': 'Ambienssi', 'Silence': 'Hiljaisuus',
        'Session': 'Sessio', 'Theme': 'Teema', 'Location': 'Paikka', 'Voice': 'Istuva',
        'AI': 'Tekoäly', 'Emoji': 'Emojit', 'Title': 'Otsikko', 'System': 'Ohjeistus',
        'ai-system': 'Järjestelmäviesti.', 'ai-user1': 'Käyttäjän syöte #1',
        'ai-ai1': 'Tekoälyn vaste #1', 'ai-user2': 'Käyttäjän syöte #2',
        'ai-ai2': 'Tekoälyn vaste #2', 'Example1': 'Esim #1', 'Example2': 'Esim #2',
        'Dark': 'Tumma', 'Light': 'Vaalea', 'theme-wide': 'Laajakuva', 'theme-43': '4:3',
        'theme-landscape': 'Vaaka', 'theme-portrait': 'Pysty', 'Empty': 'Tyhjä',
        'Adjust': 'Säätö', 'Speech': 'Puhe', 'Silence': 'Hiljaisuus', 'Framing': 'Rajaus',
        'Mixer': 'Mikseri', 'Space': 'Tila', 'Dry': 'Suora', 'voice-test': 'Äänitesti',
        'Limits': 'Rajat', 'ai-stop': 'Stop', 'ai-stopword': 'Avainsana', 'ai-user': 'Käyttäjä',
        'ai-username': 'Nimi', 'input': 'Kirjoita viesti.', 'Name': 'Nimi', 'Language': 'Kieli',
        'en': 'English', 'fi': 'Finnish', 'words': 'sanaa', 'dialogs': 'sanomaa',
        'Manuscript': 'Käsikirjoitus', 'Exclude': 'Ohita', 'Italics': 'Kursiivi',
        'Code': 'Koodi', 'Light': 'Valo', 'LightAmbient': 'Ambientti',
        'LightDirect': 'Suunnattu', 'LightSpot': 'Spotti', 'theme-full': "Täysi",
        'lt': 'Liettua', 'test-sentence': "Kirjoita tähän testilause.", 'Mid': 'Keskiosa',
        'Gesture': 'Ele', 'PoseMovement': 'Liike', 'Visible': 'Näytä',
        'Helper': 'Apuri', 'Edit': 'Muokkaa', 'Script': 'Skripti'
      },

      'en': {
        'ai-system': 'System message.', 'ai-user1': 'User example #1',
        'ai-ai1': 'AI response #1', 'ai-user2': 'User example #2',
        'ai-ai2': 'AI response #2', 'Example1': 'Example-1', 'Example2': 'Example-2',
        'theme-wide': 'Widescreen', 'theme-43': '4:3', 'theme-landscape': 'Landscape',
        'theme-portrait': 'Portrait', 'voice-test': 'Speak', 'ai-stop': 'Stop',
        'ai-user': 'User', 'input': 'Message.', 'en': 'English', 'fi': 'Finnish',
        'ai-stopword': 'Word', 'ai-username': 'Name', 'LightAmbient': 'Ambient',
        'LightDirect': 'Direct', 'LightSpot': 'Spot', 'theme-full': "Fullscreen",
        'lt': 'Lithuanian', 'test-sentence': "Write your test sentence.",
        'PoseMovement': 'Movement'
      }

    }

    // i18n
    // Default UI language is English

    function i18nWord(w, l) {
      l = l || cfg('theme-lang') || 'en';
      return ((i18n[l] && i18n[l][w]) ? i18n[l][w] : w);
    }

    function i18nTranslate(l) {
      l = l || cfg('theme-lang') || 'en';

      // Text
      d3.selectAll("[data-i18n-text]").nodes().forEach(n => {
        const e = d3.select(n);
        e.text(i18nWord(e.attr("data-i18n-text"), l));
      });

      // Title
      d3.selectAll("[data-i18n-title]").nodes().forEach(n => {
        const e = d3.select(n);
        e.attr('title', i18nWord(e.attr("data-i18n-title"), l));
      });

      // Placeholder
      d3.selectAll("[data-i18n-placeholder]").nodes().forEach(n => {
        const e = d3.select(n);
        e.attr('placeholder', i18nWord(e.attr("data-i18n-placeholder"), l));
      });

      // Site
      d3.selectAll("[data-i18n-site]").nodes().forEach(n => {
        const e = d3.select(n);
        const label = e.attr("data-i18n-site");
        const [section, ...rest] = label.split('-');
        const item = rest.join('-');
        let text = item;
        if (site[section] && site[section][item] && site[section][item][l]) {
          text = site[section][item][l];
        }
        e.text(text);
      });
    }

    // Markdown configuration
    const markedOptions = { gfm: true, breaks: true };

    // Open AI configuration
    let aiController = null;

    // ElevenLabs configuration
    const elevenBOS = {
      "text": " ",
      "voice_settings": { "stability": 0.8, "similarity_boost": true },
      "generation_config": {
        "chunk_length_schedule": [500, 500, 500, 500]
      }
    };
    let elevenSocket = null;
    let elevenInputMsgs = null;
    let elevenOutputMsg = null;
    let elevenOnProcessed = null;

    // JSON Web Token (JWT)
    let jwtExpires = 0;
    let jwt = '';

    // Get JSON Web Token
    async function jwtGet() {
      return '';
    }

    // Speak using ElevenLabs
    async function elevenSpeak(s, node = null) {
      if (!elevenSocket) {
        // Temporary reservation of WebSocket connection
        elevenSocket = { readyState: 0 };

        // Temporary stack of message until the connection is established
        elevenInputMsgs = [
          elevenBOS,
          {
            "text": s,
            "try_trigger_generation": false,
            "flush": true
          }
        ];

        // Endpoint/proxy and authentication
        let url;
        const apikey = d3.select("#apikey-eleven").property("value");
        if (apikey) {
          url = elevenTTSEndpoint[0];
          url += cfg('voice-eleven-id');
          url += elevenTTSEndpoint[1];
          elevenInputMsgs[0]["xi_api_key"] = apikey;
        } else {
          url = elevenTTSProxy[0];
          url += await jwtGet();
          url += elevenTTSProxy[1];
          url += cfg('voice-eleven-id');
          url += elevenTTSProxy[2];
        }

        // Make the connection
        elevenSocket = new WebSocket(url);

        // Connection opened
        elevenSocket.onopen = function (event) {
          elevenOutputMsg = null;
          while (elevenInputMsgs.length > 0) {
            elevenSocket.send(JSON.stringify(elevenInputMsgs.shift()));
          }
        }

        // New message received
        elevenSocket.onmessage = function (event) {
          const r = JSON.parse(event.data);

          // Speak audio
          if ((r.isFinal || r.normalizedAlignment) && elevenOutputMsg) {
            head.speakAudio(elevenOutputMsg, { lipsyncLang: cfg('voice-lipsync-lang') }, node ? addText.bind(null, node) : null);
            if (elevenOnProcessed) {
              elevenOnProcessed();
            }
            elevenOutputMsg = null;
          }

          if (!r.isFinal) {
            // New part
            if (r.alignment) {
              elevenOutputMsg = { audio: [], words: [], wtimes: [], wdurations: [] };

              // Parse chars to words
              let word = '';
              let time = 0;
              let duration = 0;
              for (let i = 0; i < r.alignment.chars.length; i++) {
                if (word.length === 0) time = r.alignment.charStartTimesMs[i];
                if (word.length && r.alignment.chars[i] === ' ') {
                  elevenOutputMsg.words.push(word);
                  elevenOutputMsg.wtimes.push(time);
                  elevenOutputMsg.wdurations.push(duration);
                  word = '';
                  duration = 0;
                } else {
                  duration += r.alignment.charDurationsMs[i];
                  word += r.alignment.chars[i];
                }
              }
              if (word.length) {
                elevenOutputMsg.words.push(word);
                elevenOutputMsg.wtimes.push(time);
                elevenOutputMsg.wdurations.push(duration);
              }
            }

            // Add audio content to message
            if (r.audio && elevenOutputMsg) {
              elevenOutputMsg.audio.push(head.b64ToArrayBuffer(r.audio));
            }
          }
        };

        // Error
        elevenSocket.onerror = function (error) {
          if (elevenOnProcessed) elevenOnProcessed();
          console.error(`WebSocket Error: ${error}`);
        };

        // Connection closed
        elevenSocket.onclose = function (event) {
          if (elevenOnProcessed) elevenOnProcessed();
          if (event.wasClean) {
            // console.info(`Connection closed cleanly, code=${event.code}, reason=${event.reason}`);
          } else {
            console.warn('Connection died');
          }
          elevenSocket = null;
        };
      } else {
        let msg = {
          "text": s
        };
        if (s.length) {
          msg["try_trigger_generation"] = false;
          msg["flush"] = true;
        }
        if (elevenSocket.readyState === 1) { // OPEN
          elevenSocket.send(JSON.stringify(msg))
        } else if (elevenSocket.readyState === 0) { // CONNECTING
          elevenInputMsgs.push(msg);
        }
      }
    }

    // Speak using Microsoft
    let microsoftSynthesizer = null;
    const microsoftQueue = [];

    async function microsoftSpeak(s, node = null, onprocessed = null) {

      if (s === null) {
        microsoftQueue.push(null);
      } else {

        // Voice config
        const id = cfg("voice-microsoft-id");
        const e = d3.select("[data-voice-microsoft-id='" + id + "']");
        const lang = e.attr("data-voice-microsoft-lang");

        // SSML
        const ssml = "<speak version='1.0' " +
          "xmlns:mstts='http://www.w3.org/2001/mstts' " +
          "xml:lang='" + lang + "'>" +
          "<voice name='" + id + "'>" +
          "<mstts:viseme type='redlips_front'/>" +
          s.replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;') +
          "</voice>" +
          "</speak>";

        microsoftQueue.push({
          ssml: ssml,
          node: node,
          onprocessed: onprocessed,
          speak: {
            audio: [], words: [], wtimes: [], wdurations: [],
            visemes: [], vtimes: [], vdurations: [], markers: [], mtimes: []
          }
        });
      }

      // If this was the first item, start the process
      if (microsoftQueue.length === 1) {
        microsoftProcessQueue();
      }
    }

    async function microsoftProcessQueue() {

      if (microsoftQueue.length) {

        const job = microsoftQueue[0];

        if (job === null) {
          microsoftQueue.shift();
          if (microsoftQueue.length === 0 && microsoftSynthesizer) {
            microsoftSynthesizer.close();
            microsoftSynthesizer = null;
          }
        } else {

          // If we do not have a speech synthesizer, create a new
          if (!microsoftSynthesizer) {

            // Create a new speech synthesizer
            let endpoint;
            let config;
            const apikey = d3.select("#apikey-microsoft").property("value");
            if (apikey) {
              endpoint = microsoftTTSEndpoint;
              config = window.SpeechSDK.SpeechConfig.fromEndpoint(endpoint, apikey);
            } else {
              endpoint = microsoftTTSProxy[0] + await jwtGet() + microsoftTTSProxy[1];
              config = window.SpeechSDK.SpeechConfig.fromEndpoint(endpoint);
            }
            config.setProperty("SpeechServiceConnection_Endpoint", endpoint);
            config.speechSynthesisOutputFormat = window.SpeechSDK.SpeechSynthesisOutputFormat.Raw22050Hz16BitMonoPcm;
            config.setProperty(window.SpeechSDK.PropertyId.SpeechServiceResponse_RequestSentenceBoundary, "true");
            microsoftSynthesizer = new window.SpeechSDK.SpeechSynthesizer(config, null);

            // Viseme conversion from Microsoft to Oculus
            // TODO: Check this conversion again!
            const visemeMap = [
              "sil", 'aa', 'aa', 'O', 'E', // 0 - 4
              'E', 'I', 'U', 'O', 'aa', // 5 - 9
              'O', 'I', 'kk', 'RR', 'nn', // 10 - 14
              'SS', 'SS', 'TH', 'FF', 'DD', // 15 - 19
              'kk', 'PP' // 20 - 21
            ];

            // Process visemes
            microsoftSynthesizer.visemeReceived = function (s, e) {
              if (microsoftQueue[0] && microsoftQueue[0].speak) {
                const o = microsoftQueue[0].speak;
                const viseme = visemeMap[e.visemeId];
                const time = e.audioOffset / 10000;

                // Calculate the duration of the previous viseme
                if (o.vdurations.length) {

                  if (o.visemes[o.visemes.length - 1] === 0) {
                    o.visemes.pop();
                    o.vtimes.pop();
                    o.vdurations.pop();
                  } else {
                    // Remove silence
                    o.vdurations[o.vdurations.length - 1] = time - o.vtimes[o.vdurations.length - 1];
                  }
                }



                // Add this viseme
                o.visemes.push(viseme);
                o.vtimes.push(time);
                o.vdurations.push(75); // Duration will be fixed when the next viseme is received
              }
            };

            // Process word boundaries and punctuations
            microsoftSynthesizer.wordBoundary = function (s, e) {
              if (microsoftQueue[0] && microsoftQueue[0].speak) {
                const o = microsoftQueue[0].speak;
                const word = e.text;
                const time = e.audioOffset / 10000;
                const duration = e.duration / 10000;

                if (e.boundaryType === "PunctuationBoundary" && o.words.length) {
                  o.words[o.words.length - 1] += word;
                } else if (e.boundaryType === "WordBoundary" || e.boundaryType === "PunctuationBoundary") {
                  o.words.push(word);
                  o.wtimes.push(time);
                  o.wdurations.push(duration);
                } else if (e.boundaryType === "SentenceBoundary") {
                  if (time > 500) {
                    o.markers.push(() => { head.lookAtCamera(500); });
                    o.mtimes.push(time - 500);
                  }
                }
              }
            };

          }

          // Speak the SSML
          microsoftSynthesizer.speakSsmlAsync(job.ssml,
            function (result) {
              if (microsoftQueue[0] && microsoftQueue[0].speak) {
                if (result.reason === window.SpeechSDK.ResultReason.SynthesizingAudioCompleted) {
                  const job = microsoftQueue[0];
                  job.speak.audio.push(result.audioData);
                  head.speakAudio(job.speak, {}, job.node ? addText.bind(null, job.node) : null);
                  if (job.onprocessed) job.onprocessed();
                }
                microsoftQueue.shift();
                microsoftProcessQueue();
              }
            }, function (err) {
              if (job.onprocessed) job.onprocessed();
              console.log(err);
              microsoftQueue.shift();
              microsoftProcessQueue();
            }
          );

        }
      }
    }



    // RECORDING
    let recordingMediaRecorder = null;
    let recordingAnalyzer = null;
    let recordingIgnoreData = false;
    let recordingChunks = [];
    const recordingMediaTypes = [
      { type: "audio/webm", ext: "webm" },
      { type: "video/mp4", ext: "mp4" }
    ];
    let recordingMediaType = {};
    for (let i = 0; i < recordingMediaTypes.length; i++) {
      if (MediaRecorder.isTypeSupported(recordingMediaTypes[i].type)) {
        recordingMediaType = recordingMediaTypes[i];
        break;
      }
    }
    const recordingBeep = "data:audio/wav;base64,//uQRAAAAWMSLwUIYAAsYkXgoQwAEaYLWfkWgAI0wWs/ItAAAGDgYtAgAyN+QWaAAihwMWm4G8QQRDiMcCBcH3Cc+CDv/7xA4Tvh9Rz/y8QADBwMWgQAZG/ILNAARQ4GLTcDeIIIhxGOBAuD7hOfBB3/94gcJ3w+o5/5eIAIAAAVwWgQAVQ2ORaIQwEMAJiDg95G4nQL7mQVWI6GwRcfsZAcsKkJvxgxEjzFUgfHoSQ9Qq7KNwqHwuB13MA4a1q/DmBrHgPcmjiGoh//EwC5nGPEmS4RcfkVKOhJf+WOgoxJclFz3kgn//dBA+ya1GhurNn8zb//9NNutNuhz31f////9vt///z+IdAEAAAK4LQIAKobHItEIYCGAExBwe8jcToF9zIKrEdDYIuP2MgOWFSE34wYiR5iqQPj0JIeoVdlG4VD4XA67mAcNa1fhzA1jwHuTRxDUQ//iYBczjHiTJcIuPyKlHQkv/LHQUYkuSi57yQT//uggfZNajQ3Vmz+ Zt//+mm3Wm3Q576v////+32///5/EOgAAADVghQAAAAA//uQZAUAB1WI0PZugAAAAAoQwAAAEk3nRd2qAAAAACiDgAAAAAAABCqEEQRLCgwpBGMlJkIz8jKhGvj4k6jzRnqasNKIeoh5gI7BJaC1A1AoNBjJgbyApVS4IDlZgDU5WUAxEKDNmmALHzZp0Fkz1FMTmGFl1FMEyodIavcCAUHDWrKAIA4aa2oCgILEBupZgHvAhEBcZ6joQBxS76AgccrFlczBvKLC0QI2cBoCFvfTDAo7eoOQInqDPBtvrDEZBNYN5xwNwxQRfw8ZQ5wQVLvO8OYU+mHvFLlDh05Mdg7BT6YrRPpCBznMB2r//xKJjyyOh+cImr2/4doscwD6neZjuZR4AgAABYAAAABy1xcdQtxYBYYZdifkUDgzzXaXn98Z0oi9ILU5mBjFANmRwlVJ3/6jYDAmxaiDG3/6xjQQCCKkRb/6kg/wW+kSJ5//rLobkLSiKmqP/0ikJuDaSaSf/6JiLYLEYnW/+kXg1WRVJL/9EmQ1YZIsv/6Qzwy5qk7/+tEU0nkls3/zIUMPKNX/6yZLf+kFgAfgGyLFAUwY//uQZAUABcd5UiNPVXAAAApAAAAAE0VZQKw9ISAAACgAAAAAVQIygIElVrFkBS+Jhi+EAuu+lKAkYUEIsmEAEoMeDmCETMvfSHTGkF5RWH7kz/ESHWPAq/kcCRhqBtMdokPdM7vil7RG98A2sc7zO6ZvTdM7pmOUAZTnJW+NXxqmd41dqJ6mLTXxrPpnV8avaIf5SvL7pndPvPpndJR9Kuu8fePvuiuhorgWjp7Mf/PRjxcFCPDkW31srioCExivv9lcwKEaHsf/7ow2Fl1T/9RkXgEhYElAoCLFtMArxwivDJJ+bR1HTKJdlEoTELCIqgEwVGSQ+hIm0NbK8WXcTEI0UPoa2NbG4y2K00JEWbZavJXkYaqo9CRHS55FcZTjKEk3NKoCYUnSQ 0rWxrZbFKbKIhOKPZe1cJKzZSaQrIyULHDZmV5K4xySsDRKWOruanGtjLJXFEmwaIbDLX0hIPBUQPVFVkQkDoUNfSoDgQGKPekoxeGzA4DUvnn4bxzcZrtJyipKfPNy5w+9lnXwgqsiyHNeSVpemw4bWb9psYeq//uQZBoABQt4yMVxYAIAAAkQoAAAHvYpL5m6AAgAACXDAAAAD59jblTirQe9upFsmZbpMudy7Lz1X1DYsxOOSWpfPqNX2WqktK0DMvuGwlbNj44TleLPQ+Gsfb+GOWOKJoIrWb3cIMeeON6lz2umTqMXV8Mj30yWPpjoSa9ujK8SyeJP5y5mOW1D6hvLepeveEAEDo0mgCRClOEgANv3B9a6fikgUSu/DmAMATrGx7nng5p5iimPNZsfQLYB2sDLIkzRKZOHGAaUyDcpFBSLG9MCQALgAIgQs2YunOszLSAyQYPVC2YdGGeHD2dTdJk1pAHGAWDjnkcLKFymS3RQZTInzySoBwMG0QueC3gMsCEYxUqlrcxK6k1LQQcsmyYeQPdC2YfuGPASCBkcVMQQqpVJshui1tkXQJQV0OXGAZMXSOEEBRirXbVRQW7ugq7IM7rPWSZyDlM3IuNEkxzCOJ0ny2ThNkyRai1b6ev//3dzNGzNb//4uAvHT5sURcZCFcuKLhOFs8mLAAEAt4UWAAIABAAAAAB4qbHo0tIjVkUU//uQZAwABfSFz3ZqQAAAAAngwAAAE1HjMp2qAAAAACZDgAAAD5UkTE1UgZEUExqYynN1qZvqIOREEFmBcJQkwdxiFtw0qEOkGYfRDifBui9MQg4QAHAqWtAWHoCxu1Yf4VfWLPIM2mHDFsbQEVGwyqQoQcwnfHeIkNt9YnkiaS1oizycqJrx4KOQjahZxWbcZgztj2c49nKmkId44S71j0c8eV9yDK6uPRzx5X18eDvjvQ6yKo9ZSS6l//8elePK/Lf//IInrOF/FvDoADYAGBMGb7 FtErm5MXMlmPAJQVgWta7Zx2go+8xJ0UiCb8LHHdftWyLJE0QIAIsI+UbXu67dZMjmgDGCGl1H+vpF4NSDckSIkk7Vd+sxEhBQMRU8j/12UIRhzSaUdQ+rQU5kGeFxm+hb1oh6pWWmv3uvmReDl0UnvtapVaIzo1jZbf/pD6ElLqSX+rUmOQNpJFa/r+sa4e/pBlAABoAAAAA3CUgShLdGIxsY7AUABPRrgCABdDuQ5GC7DqPQCgbbJUAoRSUj+NIEig0YfyWUho1VBBBA//uQZB4ABZx5zfMakeAAAAmwAAAAF5F3P0w9GtAAACfAAAAAwLhMDmAYWMgVEG1U0FIGCBgXBXAtfMH10000EEEEEECUBYln03TTTdNBDZopopYvrTTdNa325mImNg3TTPV9q3pmY0xoO6bv3r00y+IDGid/9aaaZTGMuj9mpu9Mpio1dXrr5HERTZSmqU36A3CumzN/9Robv/Xx4v9ijkSRSNLQhAWumap82WRSBUqXStV/YcS+XVLnSS+WLDroqArFkMEsAS+eWmrUzrO0oEmE40RlMZ5+ODIkAyKAGUwZ3mVKmcamcJnMW26MRPgUw6j+LkhyHGVGYjSUUKNpuJUQoOIAyDvEyG8S5yfK6dhZc0Tx1KI/gviKL6qvvFs1+bWtaz58uUNnryq6kt5RzOCkPWlVqVX2a/EEBUdU1KrXLf40GoiiFXK///qpoiDXrOgqDR38JB0bw7SoL+ZB9o1RCkQjQ2CBYZKd/+VJxZRRZlqSkKiws0WFxUyCwsKiMy7hUVFhIaCrNQsKkTIsLivwKKigsj8XYlwt/WKi2N4d//uQRCSAAjURNIHpMZBGYiaQPSYyAAABLAAAAAAAACWAAAAApUF/Mg+0aohSIRobBAsMlO//Kk4soosy1JSFRYWaLC4qZBYWFRGZdwqKiwkNBVmoWFSJkWFxX4FFRQWR+LsS4W/rFRb//////////////////////////// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////VEFHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAU291bmRib3kuZGUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMjAwNGh0dHA6Ly93d3cuc291bmRib3kuZGUAAAAAAAAAACU=";
    const recordingPlaySound = (function beep() {
      const snd = new Audio(recordingBeep);
      return function () { snd.play(); }
    })();


    async function recordingRecord() {
      if (!recordingMediaRecorder) {
        try {
          if (!navigator.mediaDevices) throw new Error("No navigator.mediaDevices available for recording.");
          let stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
          recordingMediaRecorder = new MediaRecorder(stream, { mimeType: recordingMediaType.type });
          recordingMediaRecorder.ondataavailable = async (event) => {

            // If marked ignore, do not transcribe
            if (recordingIgnoreData) {
              recordingIgnoreData = false;
              return;
            } else {
              console.log('Recorded data:', event);
              recordingIgnoreData = false;
            }

            if (event.data.size > 0) {

              // Make a transcription
              const file = new File([event.data], 'file.' + recordingMediaType.ext, { type: recordingMediaType.type });
              const form = new FormData();
              form.append("file", file);

              if (cfg("whisper-type") === "openai") {

                form.append("model", "whisper-1");
                const lang = cfg('theme-lang') || 'en';
                form.append("language", lang);
                const response = await fetch(openaiAudioTranscriptionsProxy, {
                  method: "POST",
                  body: form,
                  headers: {
                    "Authorization": "Bearer " + await jwtGet()
                  }
                });

                // Append text to input
                if (response.ok) {
                  let json;
                  try {
                    json = await response.json();
                  } catch (error) {
                    console.error("Invalid response from OpenAI");
                  }
                  if (json && json.text) {
                    const e = d3.select("#input");
                    let text = e.property("value");
                    if (text) {
                      e.property("value", text + ' ' + json.text);
                    } else {
                      e.property("value", json.text);
                    }
                  }
                }
              } else if (cfg("whisper-type") === "local") {

                form.append("temperature", "0.0");
                form.append("temperature_inc", "0.2");
                form.append("response_format", "json");

                const response = await fetch(localWhisperCppProxy + 'inference', {
                  method: "POST",
                  body: form,
                  headers: {
                    "Authorization": "Bearer " + await jwtGet()
                  }
                });

                // Append text to input
                if (response.ok) {
                  let json;
                  try {
                    json = await response.json();
                  } catch (error) {
                    console.error("Invalid response from local Whisper");
                  }
                  if (json && json.text) {
                    const e = d3.select("#input");
                    let text = e.property("value");

                    let s = json.text
                      .replace(/\[[^\]]+\]/g, '')
                      .replaceAll(/[^\p{L}\p{N},\.\p{Quotation_Mark}!€\$\+\p{Dash_Punctuation}%&\?\(\)\* ]/ug, "")
                      .replaceAll("  ", " ")
                      .trim();

                    if (text) {
                      e.property("value", text + ' ' + s);
                    } else {
                      e.property("value", s);
                    }
                  }
                }

              }

            }
          };

          // Connect to TalkingHead
          recordingAnalyzer = head.audioCtx.createAnalyser();
          const recordingSource = head.audioCtx.createMediaStreamSource(stream);
          recordingSource.connect(recordingAnalyzer);

        } catch (error) {
          d3.select("#record").classed("selected", false);
          console.error('Error accessing microphone:', error);
          return;
        }
      }

      try {
        if (recordingAnalyzer) {
          head.startListening(recordingAnalyzer, {}, (status) => {

            switch (status) {
              case 'start':
                head.lookAtCamera(2000);
                break;
              case 'stop':
                if (recordingMediaRecorder) {
                  // recordingMediaRecorder.requestData();
                  recordingMediaRecorder.stop();
                  recordingMediaRecorder.start();
                }
                break;
              case 'maxsilence':
                if (recordingMediaRecorder) {
                  recordingIgnoreData = true;
                  // recordingMediaRecorder.requestData();
                  recordingMediaRecorder.stop();
                  recordingMediaRecorder.start();
                }
                break;
              case 'maxactive':
                if (recordingMediaRecorder) {
                  recordingIgnoreData = true;
                  // recordingMediaRecorder.requestData();
                  recordingMediaRecorder.stop();
                  recordingMediaRecorder.start();
                }
                break;
            }
          });
        }

        recordingIgnoreData = false;
        if (recordingMediaRecorder) {
          recordingMediaRecorder.start();
        }

      } catch (error) {
        d3.select("#record").classed("selected", false);
        console.error('Recorder error:', error);
      }
    }


    // Number of words on a string.
    function nWords(str) {
      return str ? str.trim().split(/\s+/).length : 0;
    }

    // Default settings
    var CFG = {
      session: 0,
      sessions: [
        {
          name: "Nimetön",
          theme: { lang: 'en', brightness: "dark", ratio: "wide", layout: "port" },
          view: { image: 'NONE' },
          avatar: {},
          camera: { frame: 'full' },
          ai: {},
          voice: { background: "NONE", type: "google", google: { id: "en-GB-Standard-A" }, lipsync: { lang: 'en' } }
        },
        {
          name: "Nimetön 2",

          theme: { lang: 'en', brightness: "dark", ratio: "wide", layout: "land" },
          view: { image: 'NONE' },
          avatar: {},
          camera: { frame: 'upper' },
          ai: {},
          voice: { background: "NONE", type: "google", google: { id: "en-GB-Standard-A" }, lipsync: { lang: 'en' } }
        },
      ]
    };

    // Dynamically created icons
    const svgSelect = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M10.5858 13.4142L7.75735 10.5858L6.34314 12L10.5858 16.2427L17.6568 9.1716L16.2426 7.75739L10.5858 13.4142Z" fill="currentColor" /></svg>';
    const svgSpeak = '<svg viewBox="-2 -2 28 28" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M12 18.939C14.2091 18.939 16 17.1482 16 14.939C16 12.7299 14.2091 10.939 12 10.939C9.79086 10.939 8 12.7299 8 14.939C8 17.1482 9.79086 18.939 12 18.939ZM12 16.939C13.1046 16.939 14 16.0436 14 14.939C14 13.8345 13.1046 12.939 12 12.939C10.8954 12.939 10 13.8345 10 14.939C10 16.0436 10.8954 16.939 12 16.939Z" fill="currentColor" /><path d="M12 9.04401C13.1046 9.04401 14 8.14858 14 7.04401C14 5.93944 13.1046 5.04401 12 5.04401C10.8954 5.04401 10 5.93944 10 7.04401C10 8.14858 10.8954 9.04401 12 9.04401Z" fill="currentColor" /><path fill-rule="evenodd" clip-rule="evenodd" d="M7 1C5.34315 1 4 2.34315 4 4V20C4 21.6569 5.34315 23 7 23H17C18.6569 23 20 21.6569 20 20V4C20 2.34315 18.6569 1 17 1H7ZM17 3H7C6.44772 3 6 3.44772 6 4V20C6 20.5523 6.44772 21 7 21H17C17.5523 21 18 20.5523 18 20V4C18 3.44772 17.5523 3 17 3Z" fill="currentColor" /></svg>'
    const svgStop = '<svg viewBox="-2 -2 28 28" xmlns="http://www.w3.org/2000/svg"><path d="M6.2253 4.81108C5.83477 4.42056 5.20161 4.42056 4.81108 4.81108C4.42056 5.20161 4.42056 5.83477 4.81108 6.2253L10.5858 12L4.81114 17.7747C4.42062 18.1652 4.42062 18.7984 4.81114 19.1889C5.20167 19.5794 5.83483 19.5794 6.22535 19.1889L12 13.4142L17.7747 19.1889C18.1652 19.5794 18.7984 19.5794 19.1889 19.1889C19.5794 18.7984 19.5794 18.1652 19.1889 17.7747L13.4142 12L19.189 6.2253C19.5795 5.83477 19.5795 5.20161 19.189 4.81108C18.7985 4.42056 18.1653 4.42056 17.7748 4.81108L12 10.5858L6.2253 4.81108Z" fill="currentColor" /></svg>';
    const svgRepost = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M13.1459 11.0499L12.9716 9.05752L15.3462 8.84977C14.4471 7.98322 13.2242 7.4503 11.8769 7.4503C9.11547 7.4503 6.87689 9.68888 6.87689 12.4503C6.87689 15.2117 9.11547 17.4503 11.8769 17.4503C13.6977 17.4503 15.2911 16.4771 16.1654 15.0224L18.1682 15.5231C17.0301 17.8487 14.6405 19.4503 11.8769 19.4503C8.0109 19.4503 4.87689 16.3163 4.87689 12.4503C4.87689 8.58431 8.0109 5.4503 11.8769 5.4503C13.8233 5.4503 15.5842 6.24474 16.853 7.52706L16.6078 4.72412L18.6002 4.5498L19.1231 10.527L13.1459 11.0499Z" fill="currentColor" /></svg>';

    // Get/set config value for the current session
    function cfg(key, value) {
      if (key === undefined) return CFG.sessions[CFG.session];
      let parts = key.split('-').map(x => isNaN(x) ? x : parseInt(x));
      if (value === undefined) {
        return parts.reduce((o, p) => o ? o[p] : undefined, CFG.sessions[CFG.session]);
      } else {
        parts.reduce((o, p, i) => {
          const def = (typeof parts[i + 1] === 'number') ? [] : {};
          return (o[p] = (parts.length - 1) === i ? value : (o[p] || def));
        }, CFG.sessions[CFG.session]);
      }
    }

    // Load settings
    try {
      let json = localStorage.getItem('talkinghead');
      CFG = (json ? JSON.parse(json) : CFG);
    } catch (error) {
      alert("Invalid JSON settings");
      console.error(error);
    }

    window.cfg = cfg;

    // Save config to localStorage and show active session config
    let loadingConfig = false;
    function saveConfig() {
      if (!loadingConfig) {
        let json = JSON.stringify(CFG);
        localStorage.setItem("talkinghead", json);
        json = JSON.stringify(cfg());
        d3.select("#json").property("value", json);
      }
    }

    // Load config for the given session
    function loadConfig(session = null) {
      try {
        loadingConfig = true;
        let json = localStorage.getItem('talkinghead');
        const config = (json ? JSON.parse(json) : CFG);
        if (config && config.hasOwnProperty("session") && config.hasOwnProperty("sessions") && config.sessions.length) {
          CFG = config;
          if (session !== null && session >= 0 && session < CFG.sessions.length) {
            CFG.session = session;
            json = JSON.stringify(CFG);
            localStorage.setItem("talkinghead", json);
          }
        }
      } catch (error) {
        alert("Invalid JSON settings");
        console.error(error);
      } finally {
        loadingConfig = false;
        saveConfig();
      }
    }

    // Process string s for parts to exclude from speech/lip-sync
    // For continued stream of strings the previous state o can be given
    function excludesProcess(s, o = null) {

      // If no previous rules and states, build rules based on user settings
      if (!o || !o.rules || !Array.isArray(o.rules)) {
        o = { rules: [] };
        if (cfg('voice-exclude-italics')) {
          o.rules.push({ separator: '*', open: false });
        }
        if (cfg('voice-exclude-code')) {
          o.rules.push({ separator: '```', open: false });
        }
      }

      // Excludes is an array of [start,end] index pairs
      o.excludes = [];

      // If there are rules, process them
      o.rules.forEach(x => {
        const parts = s.split(x.separator);
        let i = 0;
        parts.forEach((y, j) => {
          const isLast = (j === (parts.length - 1));
          if (x.open) {
            const start = i - (j === 0 ? 0 : x.separator.length);
            const end = i + y.length - 1 + (isLast ? x.separator.length : 0);
            o.excludes.push([start, end]); // Exclude
          }
          if (!isLast) {
            i += y.length + x.separator.length;
            x.open = !x.open;
          }
        });
      });

      return o;
    }

    function motion(action, pose, gesture, mood) {
      try {
        head.setMood(mood || 'neutral');
      } catch (err) { }
      if (gesture && site.gestures[gesture]) {
        head.playGesture(site.gestures[gesture].name);
      }
      if (action && site.animations[action]) {
        head.playAnimation(site.animations[action].url, progressUpdate, site.animations[action].dur || 20);
      } else if (pose && site.poses[pose]) {
        head.playPose(site.poses[pose].url, progressUpdate, site.poses[pose].dur || 60);
      }
    }
    window.avatarPlayMotion = motion;
    // Select an directory entry
    function entrySelect() {
      reconnectEffect();
      const e = d3.select(this);
      const id = parseInt(e.attr("data-session"));
      d3.selectAll("[data-session]").classed('selected', false);
      e.classed('selected', true);
      loadConfig(id);
      i18nTranslate();
      d3.selectAll("[data-range]").dispatch("change");
    }

    // Move directory entry
    function entryMove() {
      const e = d3.select(this);
      const n = e.node().parentElement; // Entry
      const id = parseInt(n.id.split('-')[1]);
      const directory = d3.select("#directory").node();
      const direction = e.attr("data-entry-move");
      let session = CFG.session;

      if (direction === 'up') {

        // Swap configuration
        var tmp = CFG.sessions[id];
        CFG.sessions[id] = CFG.sessions[id - 1];
        CFG.sessions[id - 1] = tmp;

        // Swap directory entries
        d3.select(n)
          .property("id", "entry-" + (id - 1))
          .select("[data-session]")
          .attr("data-session", (id - 1));
        d3.select(n.previousElementSibling)
          .property("id", "entry-" + id)
          .select("[data-session]")
          .attr("data-session", id);
        directory.insertBefore(n, n.previousElementSibling);
        if (session === id) {
          session = id - 1;
        } else if (session === (id - 1)) {
          session = id;
        }

        // Swap sessions ids (no need to swap their places)
        const s1 = d3.select("#session-" + id);
        const s2 = d3.select("#session-" + (id - 1));
        s1.property("id", "session-" + (id - 1));
        s2.property("id", "session-" + id);

      } else if (direction === 'down') {

        // Swap configuration
        var tmp = CFG.sessions[id];
        CFG.sessions[id] = CFG.sessions[id + 1];
        CFG.sessions[id + 1] = tmp;

        // Swap directory entries
        d3.select(n)
          .property("id", "entry-" + (id + 1))
          .select("[data-session]")
          .attr("data-session", (id + 1));
        d3.select(n.nextElementSibling)
          .property("id", "entry-" + id)
          .select("[data-session]")
          .attr("data-session", id);
        directory.insertBefore(n.nextElementSibling, n);
        if (session === id) {
          session = id + 1;
        } else if (session === (id + 1)) {
          session = id;
        }

        // Swap sessions ids (no need to swap their places)
        const s1 = d3.select("#session-" + id);
        const s2 = d3.select("#session-" + (id + 1));
        s1.property("id", "session-" + (id + 1));
        s2.property("id", "session-" + id);

      }

      // Save new configuration and load the session
      saveConfig();
      loadConfig(session);
      i18nTranslate();
      d3.selectAll("[data-range]").dispatch("change");
    }

    // Turn on effect
    function turnOnEffect() {
      d3.selectAll('.starttransparent').nodes().forEach(panel => {
        const steps = 5 + Math.floor(Math.random() * 10);
        const ops = [];
        for (let i = steps; i > 0; i--) {
          ops.push({ opacity: Math.random() });
        }
        ops.push({ opacity: 1 });
        const timing = {
          duration: Math.floor(Math.random() * 2000) + 300,
          fill: "forwards"
        };
        panel.animate(ops, timing);
      });
    }

    // Reconnect effect
    function reconnectEffect() {

      // Turn off
      d3.selectAll("#avatar,#view").style("opacity", "0");
      d3.select("#left").classed("glow", false);

      // Turn on
      setTimeout(() => {
        d3.selectAll("#avatar,#view").style("opacity", "1");
        d3.select("#left").classed("glow", true);
      }, 1000);

    }

    // Talking Head
    var head;
    let morphTimer = null;

    function headLoaded(firsttime = false) {

      // Populate emoji tester
      if (firsttime) {
        const elEmojis = d3.select("#emojis");
        for (let [em, x] of Object.entries(head.animEmojis)) {
          elEmojis.append("div")
            .classed("emoji", true)
            .on('click', function (ev) {
              const e = d3.select(this);
              const name = e.text();

              // Clear timeouts
              if (morphTimer) {
                clearTimeout(morphTimer);
                morphTimer = null;
              }

              // Clear morphs
              head.getMorphTargetNames().forEach(mt => {
                const el = d3.select('#' + CSS.escape(mt));
                if (!el.empty()) {
                  let v = testerGetValue(mt, null);
                  if (parseFloat(el.property("value")) !== v) {
                    el.property("value", v);
                    d3.select(el.node().nextElementSibling).html(testerGetLabel(mt, v));
                    head.setFixedValue(mt, testerGetFixedValue(mt, v));
                  }
                }
              });

              const selected = e.classed("selected");
              d3.selectAll(".emoji").classed("selected", false);
              if (selected) {
                d3.selectAll(".emoji").classed("selected", false);
                testerUpdateMorphData();
              } else {
                e.classed("selected", true);

                // Animate
                head.playGesture(name, 3);

                morphTimer = setTimeout(() => {
                  morphTimer = null;
                  const o = head.animEmojis[name];
                  if (o) {
                    head.getMorphTargetNames().forEach(mt => {
                      let val = null;
                      if (o.vs && o.vs[mt]) {
                        val = o.vs[mt][o.vs[mt].length - 1];
                        if (Array.isArray(val)) val = val[val.length - 1];
                      }
                      const el = d3.select('#' + CSS.escape(mt));
                      if (!el.empty()) {
                        let v = testerGetValue(mt, val);
                        if (parseFloat(el.property("value")) !== v) {
                          el.property("value", v);
                          d3.select(el.node().nextElementSibling).html(testerGetLabel(mt, v));
                          head.setFixedValue(mt, testerGetFixedValue(mt, v));
                        }
                      }
                    });
                    testerUpdateMorphData();
                  }
                }, 3500);
              }
            })
            .html(em);
        }
      }

      // Populate morph targets (a.k.a. blend shapes)
      const elMorphs = d3.select("#morphs");
      elMorphs.html("");
      head.getMorphTargetNames().forEach(mt => {
        let v = head.getFixedValue(mt);

        const morph = elMorphs.append("div")
          .classed("row", true)
          .classed("morph", true);

        morph.append("div")
          .classed("text", true)
          .classed("label", true)
          .html(mt);

        morph.append("input")
          .property("id", mt)
          .property("type", "range")
          .property("min", testerGetMin(mt))
          .property("max", testerGetMax(mt))
          .property("step", testerGetStep(mt))
          .property("value", testerGetValue(mt, v))
          .on('input change keyup', function (ev) {
            const e = d3.select(this);
            const mt = e.property("id");
            let v = parseFloat(e.property("value"));
            d3.select(e.node().nextElementSibling).html(testerGetLabel(mt, v));
            head.setFixedValue(mt, testerGetFixedValue(mt, v));
            testerUpdateMorphData();
          });

        morph.append("div")
          .classed("text", true)
          .html(testerGetLabel(mt, v));
      });

      // Populate skinned meshes
      const elSkinnedMeshes = d3.select("#skinnedmeshes");
      elSkinnedMeshes.html("");
      head.armature.traverse(x => {
        if (x.isSkinnedMesh) {
          elSkinnedMeshes.append("div")
            .classed("command", true)
            .classed("selected", x.visible)
            .on('click', function (ev) {
              const e = d3.select(this);
              const sel = e.classed('selected');
              e.classed('selected', !sel)
              x.visible = !sel;
            })
            .html(x.name);
        }
      });

      // Populate dynamic bones
      const elBonesHelpers = d3.select("#boneshelpers");
      const elBonesSelect = d3.select("#bonesselect");
      elBonesHelpers.html("");
      elBonesSelect.html("");
      const names = head.dynamicbones?.getBoneNames();
      if (names && names.length) {

        // Director
        d3.select("#bonesfeaturedynamic")
          .on("click", null)
          .on("click", function (ev) {
            const e = d3.select(this);
            const sel = !e.classed('selected');
            e.classed('selected', sel);
            if (sel === true) {
              head.dynamicbones.start();
            } else {
              head.dynamicbones.stop();
            }
          })
          .classed("selected", true)
          .classed("disabled", false);
        d3.select("#bonesfeatureexcludes")
          .on("click", null)
          .on("click", function (ev) {
            const e = d3.select(this);
            const sel = !e.classed('selected');
            e.classed('selected', sel);
            head.dynamicbones.setOptionValue("isExcludes", sel);
          })
          .classed("selected", true)
          .classed("disabled", false);
        d3.select("#bonesfeaturepivots")
          .on("click", null)
          .on("click", function (ev) {
            const e = d3.select(this);
            const sel = !e.classed('selected');
            e.classed('selected', sel);
            head.dynamicbones.setOptionValue("isPivots", sel);
          })
          .classed("selected", true)
          .classed("disabled", false);
        d3.select("#bonesfeaturelimits")
          .on("click", null)
          .on("click", function (ev) {
            const e = d3.select(this);
            const sel = !e.classed('selected');
            e.classed('selected', sel);
            head.dynamicbones.setOptionValue("isLimits", sel);
          })
          .classed("selected", true)
          .classed("disabled", false);

        // Bone testers
        d3.selectAll(".bonetester").on("click", function (ev) {
          const e = d3.select(this);
          const name = d3.select(".dynamicbone.selected").text();
          const data = head?.dynamicbones?.data?.find(x => x.name === name);
          if (data) {
            let dir = 0;
            switch (e.text()) {
              case 'x': dir = 0; break;
              case 'y': dir = 1; break;
              case 'z': dir = 2; break;
              case 't': dir = 3;
            }
            data.v[dir] = 100;
          }
        });

        // Show all
        elBonesHelpers.append("div")
          .property("id", "bonehelpershowall")
          .classed("command", true)
          .on('click', function (ev) {
            const e = d3.select(this);
            const sel = e.classed('selected');
            e.classed('selected', !sel)
            if (sel) {
              head.dynamicbones.showHelpers(false);
            } else {
              head.dynamicbones.showHelpers(true);
            }
          })
          .html("ALL");

        names.forEach((name, i) => {

          elBonesHelpers.append("div")
            .classed("command", true)
            .classed("bonehelper", true)
            .classed("selected", head.dynamicbones.getValue(name, "helper") || false)
            .on('click', function (ev) {
              const e = d3.select(this);
              const sel = e.classed('selected');
              e.classed('selected', !sel)
              head.dynamicbones.setValue(name, "helper", !sel);
            })
            .html(name);

          elBonesSelect.append("div")
            .classed("command", true)
            .classed("dynamicbone", true)
            .classed("selected", i === 0)
            .on('click', function (ev) {
              const e = d3.select(this);
              d3.selectAll(".dynamicbone").classed('selected', false);
              e.classed('selected', true);

              const type = head.dynamicbones.getValue(name, "type");
              d3.selectAll(".bonetype").classed('selected', false);
              d3.select("#bonetype" + type).classed('selected', true);

              let k = head.dynamicbones.getValue(name, "stiffness");
              d3.select("#stiffnesslock").classed("selected", !Number.isNaN(k));
              if (!Number.isNaN(k)) {
                k = Array(4).fill(k);
              }
              d3.select('#stiffnessx').property('value', k[0]).node().nextElementSibling.textContent = k[0];
              d3.select('#stiffnessy').property('value', k[1]).node().nextElementSibling.textContent = k[1];
              d3.select('#stiffnessz').property('value', k[2]).node().nextElementSibling.textContent = k[2];
              d3.select('#stiffnesst').property('value', k[3]).node().nextElementSibling.textContent = k[3];

              let c = head.dynamicbones.getValue(name, "damping");
              d3.select("#dampinglock").classed("selected", !Number.isNaN(c));
              if (!Number.isNaN(k)) {
                c = Array(4).fill(c);
              }
              d3.select('#dampingx').property('value', c[0]).node().nextElementSibling.textContent = c[0];
              d3.select('#dampingy').property('value', c[1]).node().nextElementSibling.textContent = c[1];
              d3.select('#dampingz').property('value', c[2]).node().nextElementSibling.textContent = c[2];
              d3.select('#dampingt').property('value', c[3]).node().nextElementSibling.textContent = c[3];

              const ext = head.dynamicbones.getValue(name, "external") || 1.0;
              d3.select('#external').property('value', ext).node().nextElementSibling.textContent = ext;

              let l = head.dynamicbones.getValue(name, "limits");
              if (l) {
                if (!l[0]) l[0] = [null, null];
                if (!l[1]) l[1] = [null, null];
                if (!l[2]) l[2] = [null, null];
                if (!l[3]) l[3] = [null, null];
              } else {
                l = [[null, null], [null, null], [null, null], [null, null]];
              }
              l = l.flat();
              ['#limitsx1', '#limitsx2', '#limitsy1', '#limitsy2', '#limitsz1', '#limitsz2', '#limitst1', '#limitst2'].forEach((x, i) => {
                d3.select(x + 'null').classed("selected", l[i] !== null);
                d3.select(x)
                  .property("value", l[i])
                  .classed("disabled", l[i] === null)
                  .node().nextElementSibling.textContent = l[i] === null ? "" : (l[i] + ' m');
              });

              const deltal = head.dynamicbones.getValue(name, "deltaLocal") || [0, 0, 0];
              d3.select('#deltalx').property('value', deltal[0]).node().nextElementSibling.textContent = deltal[0];
              d3.select('#deltaly').property('value', deltal[1]).node().nextElementSibling.textContent = deltal[1];
              d3.select('#deltalz').property('value', deltal[2]).node().nextElementSibling.textContent = deltal[2];

              const deltaw = head.dynamicbones.getValue(name, "deltaWorld") || [0, 0, 0];
              d3.select('#deltawx').property('value', deltaw[0]).node().nextElementSibling.textContent = deltaw[0];
              d3.select('#deltawy').property('value', deltaw[1]).node().nextElementSibling.textContent = deltaw[1];
              d3.select('#deltawz').property('value', deltaw[2]).node().nextElementSibling.textContent = deltaw[2];

              const pivot = head.dynamicbones.getValue(name, "pivot") || false;
              d3.select("#pivot").classed("selected", pivot);

            })
            .html(name);
        });

        d3.select('#bonesdata').property("value", JSON.stringify(head.dynamicbones.getConfig()));

        // Change type
        d3.selectAll(".bonetype")
          .classed("disabled", false)
          .on('click', null)
          .on('click', function (ev) {
            const e = d3.select(this);
            d3.selectAll(".bonetype").classed('selected', false);
            e.classed('selected', true);
            const name = d3.select(".dynamicbone.selected").text();
            const type = e.text();
            head.dynamicbones.setValue(name, "type", type);
            d3.select('#bonesdata').property("value", JSON.stringify(head.dynamicbones.getConfig()));
          });

        // Change stiffness
        d3.selectAll(".stiffness")
          .classed("disabled", false)
          .on('input.update change.update keyup.update', null)
          .on('input.update change.update keyup.update', function (ev) {
            const e = d3.select(this);
            const name = d3.select(".dynamicbone.selected").text();
            const lock = d3.select("#stiffnesslock").classed("selected");
            if (lock) {
              d3.selectAll(".stiffness").property('value', e.property('value')).nodes().forEach(x => {
                x.nextElementSibling.textContent = e.property('value');
              });
            }
            head.dynamicbones.setValue(name, "stiffness", [
              parseFloat(d3.select('#stiffnessx').property('value')),
              parseFloat(d3.select('#stiffnessy').property('value')),
              parseFloat(d3.select('#stiffnessz').property('value')),
              parseFloat(d3.select('#stiffnesst').property('value'))
            ]);
            d3.select('#bonesdata').property("value", JSON.stringify(head.dynamicbones.getConfig()));
          });

        // Change damping
        d3.selectAll(".damping")
          .classed("disabled", false)
          .on('input.update change.update keyup.update', null)
          .on('input.update change.update keyup.update', function (ev) {
            const e = d3.select(this);
            const name = d3.select(".dynamicbone.selected").text();
            const lock = d3.select("#dampinglock").classed("selected");
            if (lock) {
              d3.selectAll(".damping").property('value', e.property('value')).nodes().forEach(x => {
                x.nextElementSibling.textContent = e.property('value');
              });
            }
            head.dynamicbones.setValue(name, "damping", [
              parseFloat(d3.select('#dampingx').property('value')),
              parseFloat(d3.select('#dampingy').property('value')),
              parseFloat(d3.select('#dampingz').property('value')),
              parseFloat(d3.select('#dampingt').property('value'))
            ]);
            d3.select('#bonesdata').property("value", JSON.stringify(head.dynamicbones.getConfig()));
          });

        // Locks
        d3.selectAll("#stiffnesslock,#dampinglock")
          .classed("disabled", false)
          .on("click", null)
          .on('click', function (ev) {
            const e = d3.select(this);
            const sel = e.classed('selected');
            e.classed('selected', !sel);
            d3.select(this.parentNode).select("input").dispatch("change");
          });

        // Change external
        d3.select("#external")
          .classed("disabled", false)
          .on('input.update change.update keyup.update', null)
          .on('input.update change.update keyup.update', function (ev) {
            const name = d3.select(".dynamicbone.selected").text();
            head.dynamicbones.setValue(name, "external",
              parseFloat(d3.select('#external').property('value'))
            );
            d3.select('#bonesdata').property("value", JSON.stringify(head.dynamicbones.getConfig()));
          });

        // Change limits
        d3.selectAll(".limits")
          .classed("disabled", false)
          .on('input.update change.update keyup.update', null)
          .on('input.update change.update keyup.update', function (ev) {
            let val = ['#limitsx1', '#limitsx2', '#limitsy1', '#limitsy2', '#limitsz1', '#limitsz2', '#limitst1', '#limitst2'].map((x, i) => {
              return d3.select(x + 'null').classed("selected") ? parseFloat(d3.select(x).property("value")) : null;
            });
            val = [
              [val[0], val[1]],
              [val[2], val[3]],
              [val[4], val[5]],
              [val[6], val[7]]
            ];
            val = val.map(x => (x[0] === null && x[1] === null) ? null : x);
            if (val.every(x => x === null)) val = null;
            const name = d3.select(".dynamicbone.selected").text();
            head.dynamicbones.setValue(name, "limits", val);
            d3.select('#bonesdata').property("value", JSON.stringify(head.dynamicbones.getConfig()));
          });

        // Change limits
        d3.selectAll(".limitsnull")
          .classed("disabled", false)
          .on('click', null)
          .on('click', function (ev) {
            const e = d3.select(this);
            const sel = e.classed('selected');
            e.classed('selected', !sel)
            if (!sel) {
              e.node().nextElementSibling.classList.remove('disabled');
            } else {
              e.node().nextElementSibling.classList.add('disabled');
            }
            d3.select(this.parentNode).select("input").dispatch("change");
          });

        // Change delta local
        d3.selectAll(".deltal")
          .classed("disabled", false)
          .on('input.update change.update keyup.update', null)
          .on('input.update change.update keyup.update', function (ev) {
            const name = d3.select(".dynamicbone.selected").text();
            head.dynamicbones.setValue(name, "deltaLocal", [
              parseFloat(d3.select('#deltalx').property('value')),
              parseFloat(d3.select('#deltaly').property('value')),
              parseFloat(d3.select('#deltalz').property('value'))
            ]);
            d3.select('#bonesdata').property("value", JSON.stringify(head.dynamicbones.getConfig()));
          });

        // Change delta world
        d3.selectAll(".deltaw")
          .classed("disabled", false)
          .on('input.update change.update keyup.update', null)
          .on('input.update change.update keyup.update', function (ev) {
            const name = d3.select(".dynamicbone.selected").text();
            head.dynamicbones.setValue(name, "deltaWorld", [
              parseFloat(d3.select('#deltawx').property('value')),
              parseFloat(d3.select('#deltawy').property('value')),
              parseFloat(d3.select('#deltawz').property('value'))
            ]);
            d3.select('#bonesdata').property("value", JSON.stringify(head.dynamicbones.getConfig()));
          });

        // Change pivot
        d3.select("#pivot")
          .classed("disabled", false)
          .on('click', null)
          .on('click', function (ev) {
            const e = d3.select(this);
            const sel = e.classed('selected');
            e.classed('selected', !sel)
            const name = d3.select(".dynamicbone.selected").text();
            head.dynamicbones.setValue(name, "pivot", !sel);
            d3.select('#bonesdata').property("value", JSON.stringify(head.dynamicbones.getConfig()));
          });

        // Select first bone
        d3.select('.dynamicbone').dispatch("click");

      } else {

        d3.selectAll("#bonesfeaturedynamic,#bonesfeatureexcludes,#bonesfeaturepivots,#bonesfeaturelimits,.bonetype,#pivot,#stiffnesslock,#dampinglock")
          .classed("selected", false)
          .classed("disabled", true)
          .on("click", null);

        let row = elBonesHelpers.append("div")
          .classed("row", true)
          .classed("bone", true);

        row.append("div")
          .classed("text", true)
          .classed("label", true)
          .html("N/A");

        row = elBonesSelect.append("div")
          .classed("row", true)
          .classed("bone", true);

        row.append("div")
          .classed("text", true)
          .classed("label", true)
          .html("N/A");

        d3.selectAll(".stiffness,.damping,#external,.limits,.deltal,.deltaw")
          .classed("disabled", true)
          .on('input.update change.update keyup.update', null);

        d3.select('#bonesdata').property("value", "");
      }

      // Unlock Web Audio API
      if (firsttime) {
        if (head.audioCtx.state === 'suspended') {
          if ('ontouchstart' in window) {
            let unlockWebAudioAPI = function () {
              head.audioCtx.resume().then(() => {
                document.body.removeEventListener('touchstart', unlockWebAudioAPI);
                document.body.removeEventListener('touchend', unlockWebAudioAPI);
              });
            };
            document.body.addEventListener('touchstart', unlockWebAudioAPI, false);
            document.body.addEventListener('touchend', unlockWebAudioAPI, false);
          }
        }

        setTimeout(() => {
          turnOnEffect();
          reconnectEffect();
          loadConfig();
        }, 1000);
      }
    }

    // Update progress bar
    let progressTimeout;
    function progressUpdate(ev) {
      if (progressTimeout) {
        clearTimeout(progressTimeout);
        progressTimeout = null;
      } else {
        d3.select("#loading").style("display", "block");
      }
      let hideMs = 1000;
      if (ev.lengthComputable) {
        let val = Math.min(100, Math.round(ev.loaded / ev.total * 100));
        d3.select("#loading-top").style("clip-path", "inset(0 " + (100 - val) + "% 0 0)");
        d3.selectAll("#loading-value").text(val + "%");
        if (val < 100) hideMs = 3000;
      } else {
        d3.select("#loading-top").style("clip-path", "inset(0 0 0 0)");
        d3.selectAll("#loading-value").text("" + ev.loaded);
      }
      progressTimeout = setTimeout(() => {
        d3.select("#loading").style("display", "none");
        progressTimeout = null;
      }, hideMs);
    }

    // Update progress bar using media loading progress
    function progressMedia() {
      let bf = this.buffered;
      let dur = this.duration;
      let state = this.readyState;
      if (bf && bf.length && !Number.isNaN(dur) && dur < Infinity && state > 0 && state < 4) {
        progressUpdate({
          loaded: bf.end(bf.length - 1) - bf.start(bf.length - 1),
          total: dur,
          lengthComputable: (dur > 0)
        });
      }
    }

    function errorShow(error) {
      console.error(error);
    }

    function testerUpdateMorphData() {
      let s = '{';
      for (let mt of head.getMorphTargetNames()) {
        const el = d3.select('#' + CSS.escape(mt));
        if (!el.empty()) {
          const v = testerGetFixedValue(mt, parseFloat(el.property("value")));
          if (v !== null) {
            s += (s.length > 1 ? ',' : '') + ' ' + mt + ': [' + v + ']';
          }
        }
      }
      s += ' }';
      d3.select('#morphdata').property("value", s).dispatch('change');
    }

    function testerGetValue(mt, v) {
      if (mt.startsWith('headRotate') || mt.startsWith('bodyRotate') || mt.startsWith('eyesRotate')) {
        return (v === null || v === undefined) ? 0 : v;
      } else {
        return (v === null || v === undefined) ? -0.1 : v;
      }
    }

    function testerGetFixedValue(mt, v) {
      if (mt.startsWith('headRotate') || mt.startsWith('bodyRotate') || mt.startsWith('eyesRotate')) {
        return (v === 0 ? null : v);
      } else {
        return (v >= 0 ? v : null);
      }
    }

    function testerGetMin(mt) {
      if (mt.startsWith('headRotate') || mt.startsWith('bodyRotate')) {
        return -0.5;
      } else if (mt.startsWith('eyesRotate')) {
        return -1;
      } else {
        return -0.1;
      }
    }

    function testerGetMax(mt) {
      return (mt.startsWith('headRotate') || mt.startsWith('bodyRotate')) ? 0.5 : 1;
    }

    function testerGetStep(mt) {
      return (mt.startsWith('headRotate') || mt.startsWith('bodyRotate') || mt.startsWith('eyesRotate')) ? 0.05 : 0.1;
    }

    function testerGetLabel(mt, v) {
      if (mt.startsWith('headRotate') || mt.startsWith('bodyRotate') || mt.startsWith('eyesRotate')) {
        return (v ? v : '');
      } else {
        return (v >= 0 ? v : '');
      }
    }


    // Script
    let scriptIsRunning = false;
    let scriptBlocks = [];
    let scriptIndex = 0;

    function scriptStatus(msg = null) {
      const el = d3.select("#scriptstatus");
      if (msg) {
        el.text(msg);
      } else if (scriptIsRunning) {
        el.text("ACTIVE");
      } else {
        const size = scriptBlocks.length;
        if (size === 0) {
          el.text("");
        } else if (scriptIndex === 0) {
          el.text("READY");
        } else if (scriptIndex >= size) {
          el.text("END");
        } else {
          el.text((scriptIndex + 1) + "/" + size);
        }
      }
    }

    function scriptInit() {
      const script = d3.select("#script").property("value");
      scriptBlocks = script
        .replaceAll('\n\n\n', '\n\n').trim()
        .split('\n\n')
        .map(x => x.trim().split('\n')
          .map(y => y.trim()).filter(y => y.length))
        .filter(y => y.length);
      scriptIndex = 0;
      scriptStatus();
    }





    // Page ready
    document.addEventListener('DOMContentLoaded', async function (e) {



      // Create the talking head avatar
      const nodeAvatar = document.getElementById('avatar');
      head = new TalkingHead(nodeAvatar, {
        jwtGet: jwtGet,
        ttsEndpoint: googleTTSProxy,
        cameraZoomEnable: true,
        cameraPanEnable: true,
        cameraView: 'upper',
        avatarMood: 'neutral',
        lipsyncModules: ["en", "fi", "lt"],
        // Stats display that can be used when testing performance
        statsNode: document.body,
        statsStyle: "position: fixed; bottom: 0px; left: 0px; cursor: pointer; opacity: 0.9; z-index: 10000;"
      });
      window.head = head;

      // Follow double clicks
      document.body.addEventListener('dblclick', function (e) {
        e = e || window.event;
        if (!head.touchAt(e.clientX, e.clientY)) {
          head.lookAt(e.clientX, e.clientY, 500)
        }
      });




      // Change UI language
      d3.selectAll("[data-theme-lang]").on('click.command', function (ev) {
        const e = d3.select(this);
        d3.selectAll("[data-theme-lang]").classed('selected', false);
        e.classed('selected', true);
        const lang = e.attr("data-theme-lang");
        cfg('theme-lang', lang);
        i18nTranslate();
        d3.selectAll("[data-range]").dispatch("change");
      });

      // Speak test
      d3.select("#playtest").on("click", function (ev) {
        const e = d3.select("[data-voice-test]");
        let text = e.property("value");
        if (head && text.length) {
          if (cfg('voice-type') === 'eleven') {
            elevenSpeak(text + " ");
            elevenSpeak("");
          } else if (cfg('voice-type') === 'microsoft') {
            microsoftSpeak(text);
            microsoftSpeak(null);
          } else {
            const exclude = excludesProcess(text);
            head.speakText(text, {
              lipsyncLang: cfg('voice-lipsync-lang'),
              ttsVoice: cfg('voice-google-id'),
              ttsRate: cfg('voice-google-rate'),
              ttsPitch: cfg('voice-google-pitch')
            }, null, exclude.excludes);
          }
        }
      });





      // Reset range
      d3.selectAll("[data-range-reset]").on('click.command', function (ev) {
        const e = d3.select(this);
        const target = e.attr("data-target");
        const value = parseFloat(e.attr("data-range-reset"));
        d3.select("[data-" + target + "]").property("value", value).dispatch("change");
      });

      // Show value labels
      d3.selectAll("[data-range]").on('input.label change.label keyup.label', function (ev) {
        const e = d3.select(this);
        const n = e.node();
        const type = e.attr("data-range");
        let v = '';
        if (type === 'float') {
          v = Math.round(100 * n.value) / 100;
        } else if (type === 'second') {
          v = Math.round(100 * n.value) / 100 + ' s';
        } else if (type === 'percentage') {
          v = Math.round(100 * n.value) + '%';
        } else if (type === 'px') {
          v = n.value + ' px';
        } else if (type === 'meter') {
          v = n.value + ' m';
        } else if (type === 'radian') {
          v = n.value + ' rad';
        } else if (type === 'word') {
          v = n.value + ' ' + i18nWord('words');
        } else if (type === 'dialog') {
          v = n.value + ' ' + i18nWord('dialogs');
        }
        n.nextElementSibling.textContent = v;
      });

      d3.selectAll("[data-item='name']").on('input.command change.command keyup.command', function (ev) {
        const e = d3.select(this);
        const name = e.property("value");
        d3.select("#entry-" + CFG.session).select("div").text(name);
        d3.select("#name").text(name);
      });

      // Show/hide pages
      d3.selectAll("[data-show]").on('click.command', function (ev) {
        const e = d3.select(this);
        const sel = e.classed("selected");
        const show = e.attr("data-show");
        const parts = show.split("-");

        d3.selectAll("[data-show*='" + parts[0] + "-']").classed("selected", false);
        d3.selectAll("[id*='" + parts[0] + "-']").classed("hidden", true);
        if (!sel) {
          e.classed("selected", true);
          d3.select('#' + show)
            .classed("hidden", false)
            .selectAll("textarea").dispatch("keyup");
          if (parts[0] === 'right') {
            d3.select("#right-sessions").classed("hidden", true);
          }
        } else {
          if (parts[0] === 'right') {
            d3.select("#right-sessions").classed("hidden", false);
          }
        }
      });

      d3.selectAll("[data-theme-ratio]").on('click.command', function (ev) {
        const e = d3.select(this);
        d3.selectAll("[data-theme-ratio]").classed('selected', false);
        e.classed('selected', true);
        const main = d3.select("#main");
        d3.selectAll("[data-theme-ratio]").nodes().forEach(x => {
          main.classed("ratio-" + x.dataset.themeRatio, false);
        });
        let ratio = 'ratio-' + d3.select("[data-theme-ratio].selected").attr('data-theme-ratio');
        main.classed(ratio, true);
      });

      d3.selectAll("[data-theme-layout]").on('click.command', function (ev) {
        const e = d3.select(this);
        d3.selectAll("[data-theme-layout]").classed('selected', false);
        e.classed('selected', true);
        const main = d3.select("#main");
        d3.selectAll("[data-theme-layout]").nodes().forEach(x => {
          main.classed("layout-" + x.dataset.themeLayout, false);
        });
        let layout = 'layout-' + d3.select("[data-theme-layout].selected").attr('data-theme-layout');
        main.classed(layout, true);
      });

      d3.selectAll("[data-theme-brightness]").on('click.command', function (ev) {
        const e = d3.select(this);
        d3.selectAll("[data-theme-brightness]").classed('selected', false);
        e.classed('selected', true);
        const body = d3.select("body");
        d3.selectAll("[data-theme-brightness]").nodes().forEach(x => {
          body.classed("theme-" + x.dataset.themeBrightness, false);
        });
        let theme = 'theme-' + d3.select("[data-theme-brightness].selected").attr('data-theme-brightness');
        body.classed(theme, true);
      });

      d3.selectAll("[data-avatar-name]").on('click.command', async function (ev) {
        const e = d3.select(this);
        d3.selectAll("[data-avatar-name]").classed('selected', false);
        let avatar = e.attr('data-avatar-name');
        d3.selectAll("[data-avatar-name='" + avatar + "']").classed("selected", true);
        if (avatar === 'FILE') {
          // Do nothing
        } else if (avatar === 'URL') {
          let url = cfg('avatar-url');
          d3.selectAll("[data-pose],[data-animation],#pause").classed("selected", false);
          const o = {
            url: url,
            body: cfg('avatar-body')
          };
          if (url !== head.avatar?.url) {
            try {
              await head.showAvatar(o, progressUpdate);
              headLoaded();
              d3.select("[data-camera-frame].selected").dispatch('click');
            } catch (error) {
              errorShow(error);
            }
          }
        } else {
          const name = e.attr('data-avatar-name');
          d3.selectAll("[data-pose],[data-animation],#pause").classed("selected", false);
          if (site.avatars[name].url !== head.avatar?.url) {
            try {
              await head.showAvatar(site.avatars[name], progressUpdate);
              headLoaded();
              d3.select("[data-camera-frame].selected").dispatch('click');
            } catch (error) {
              errorShow(error);
            }
          }
        }
      });

      // Open avatar file
      d3.select("#avatar-name-file").on('change', async function (ev) {
        let file = ev.target.files[0];
        var reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = async (ev2) => {
          d3.selectAll("[data-pose],[data-animation],#pause").classed("selected", false);
          const o = {
            url: ev2.target.result,
            body: cfg('avatar-body')
          };
          try {
            await head.showAvatar(o, progressUpdate);
            headLoaded();
            d3.select("[data-camera-frame].selected").dispatch('click');
          } catch (error) {
            errorShow(error);
          }
        }
        ev.target.value = '';
      });

      d3.selectAll("[data-avatar-brightness],[data-avatar-contrast],[data-avatar-saturate]").on('input.command change.command keyup.command', function (ev) {
        const e = d3.select(this);
        let filters = [];
        d3.selectAll("[data-avatar-brightness],[data-avatar-contrast],[data-avatar-saturate]").nodes().forEach(node => {
          filters.push((node.dataset.avatarBrightness || node.dataset.avatarContrast || node.dataset.avatarSaturate) + '(' + node.value + ')');
        });
        d3.select("#avatar").style("filter", filters.join(' '));
      });

      d3.selectAll("[data-avatar-body]").on('click.command', function (ev) {
        const e = d3.select(this);
        d3.selectAll("[data-avatar-body]").classed('selected', false);
        e.classed('selected', true);
      });

      d3.selectAll("[data-view-image]").on('click.command', function (ev) {
        const e = d3.select(this);
        d3.selectAll("[data-view-image]").classed('selected', false);
        let view = e.attr('data-view-image');
        d3.selectAll("[data-view-image='" + view + "']").classed("selected", true);
        if (view === 'NONE') {
          CFG.sessions[CFG.session].view.image = "NONE";
          d3.select("#main")
            .classed("presence-video", false)
            .classed("presence-vr", true);
          d3.select("#view-video").attr("src", "");
          d3.select("#video").node().load();
          d3.select("#view").style("background-image", "none");
        } else if (view === 'FILE') {
          // Do nothing
        } else if (view === 'URL') {
          CFG.sessions[CFG.session].view.image = "URL";
          d3.select("#main")
            .classed("presence-video", true)
            .classed("presence-vr", false);
          d3.select("#view-video").attr("src", "");
          d3.select("#video").node().load();
          const image = cfg('view-url');
          d3.select("#view").style("background-image", "url(" + image + ")");
        } else {
          CFG.sessions[CFG.session].view.image = view;
          d3.select("#main")
            .classed("presence-video", true)
            .classed("presence-vr", false);
          const image = e.attr('data-view-image');
          const type = e.attr('data-image-type');
          if (type.startsWith('video/')) {
            d3.select("#view-video")
              .attr("src", image)
              .attr("type", type);
            d3.select("#video").node().load();
            d3.select("#view").style("background-image", "none");
          } else if (type.startsWith('image/')) {
            d3.select("#view-video").attr("src", "");
            d3.select("#video").node().load();
            d3.select("#view").style("background-image", "url(" + image + ")");
          }
        }
      });

      // Open view image file
      d3.select("#view-image-file").on('change', function (ev) {
        let file = ev.target.files[0];
        var reader = new FileReader();
        if (file.type.startsWith('image/')) {
          d3.select("#main")
            .classed("presence-video", true)
            .classed("presence-vr", false);
          reader.readAsDataURL(file);
          reader.onload = (ev2) => {
            d3.select("#view-video").attr("src", "");
            d3.select("#video").node().load();
            d3.select("#view").style("background-image", "url(" + ev2.target.result + ")");
          }
        } else if (file.type.startsWith('video/')) {
          d3.select("#main")
            .classed("presence-video", true)
            .classed("presence-vr", false);
          reader.readAsDataURL(file);
          reader.onload = (ev2) => {
            let content = ev2.target.result;
            d3.select("#view-video").attr("src", content);
            d3.select("#video").node().load();
          }
        }
        ev.target.value = '';
      });

      d3.select("[data-pose-movement]").on('input.command change.command keyup.command', function (ev) {
        let factor = parseFloat(d3.select("[data-pose-movement]").property("value"));
        head.opt.modelMovementFactor = factor;
        head.setPoseFromTemplate(head.poseCurrentTemplate);
      });

      d3.selectAll("[data-camera-frame]").on('click.command', function (ev) {
        const e = d3.select(this);
        d3.selectAll("[data-camera-frame]").classed('selected', false);
        const camera = e.attr('data-camera-frame');
        d3.selectAll("[data-camera-frame='" + camera + "']").classed("selected", true);
        const opt = {
          cameraX: parseFloat(cfg("camera-x") || 0),
          cameraY: parseFloat(cfg("camera-y") || 0),
          cameraDistance: parseFloat(cfg("camera-d") || 0),
          cameraRotateX: parseFloat(cfg("camera-rotx") || 0),
          cameraRotateY: parseFloat(cfg("camera-roty") || 0)
        };
        head.setView(camera, opt);
      });

      d3.selectAll("[data-camera-x],[data-camera-y],[data-camera-d],[data-camera-rotx],[data-camera-roty]").on('input.command change.command keyup.command', function (ev) {
        d3.select("[data-camera-frame].selected").dispatch('click');
      });

      d3.select("[data-camera-fps]").on('input.command change.command keyup.command', function (ev) {
        let fps = parseFloat(d3.select("[data-camera-fps]").property("value"));
        head.opt.modelFPS = fps;
        head.animFrameDur = 1000 / fps;
      });

      function setLightingData() {
        let o = {
          lightAmbientColor: d3.select("[data-light-ambient-color]").property("value"),
          lightAmbientIntensity: parseFloat(d3.select("[data-light-ambient-intensity]").property("value")),
          lightDirectColor: d3.select("[data-light-direct-color]").property("value"),
          lightDirectIntensity: parseFloat(d3.select("[data-light-direct-intensity]").property("value")),
          lightDirectPhi: parseFloat(d3.select("[data-light-direct-phi]").property("value")),
          lightDirectTheta: parseFloat(d3.select("[data-light-direct-theta]").property("value")),
          lightSpotColor: d3.select("[data-light-spot-color]").property("value"),
          lightSpotIntensity: parseFloat(d3.select("[data-light-spot-intensity]").property("value")),
          lightSpotPhi: parseFloat(d3.select("[data-light-spot-phi]").property("value")),
          lightSpotTheta: parseFloat(d3.select("[data-light-spot-theta]").property("value")),
          lightSpotDispersion: parseFloat(d3.select("[data-light-spot-dispersion]").property("value"))
        };
        d3.select('#lightingdata').property("value", JSON.stringify(o));
      }

      d3.selectAll("[data-light-ambient-color],[data-light-ambient-intensity]").on('input.command change.command keyup.command', function (ev) {
        const e = d3.select(this);
        let o = {
          lightAmbientColor: d3.select("[data-light-ambient-color]").property("value"),
          lightAmbientIntensity: parseFloat(d3.select("[data-light-ambient-intensity]").property("value"))
        };
        head.setLighting(o);
        setLightingData();
      });

      d3.selectAll("[data-light-direct-color],[data-light-direct-intensity],[data-light-direct-phi],[data-light-direct-theta]").on('input.command change.command keyup.command', function (ev) {
        const e = d3.select(this);
        let o = {
          lightDirectColor: d3.select("[data-light-direct-color]").property("value"),
          lightDirectIntensity: parseFloat(d3.select("[data-light-direct-intensity]").property("value")),
          lightDirectPhi: parseFloat(d3.select("[data-light-direct-phi]").property("value")),
          lightDirectTheta: parseFloat(d3.select("[data-light-direct-theta]").property("value"))
        };
        head.setLighting(o);
        setLightingData();
      });

      d3.selectAll("[data-light-spot-color],[data-light-spot-intensity],[data-light-spot-phi],[data-light-spot-theta],[data-light-spot-dispersion]").on('input.command change.command keyup.command', function (ev) {
        const e = d3.select(this);
        let o = {
          lightSpotColor: d3.select("[data-light-spot-color]").property("value"),
          lightSpotIntensity: parseFloat(d3.select("[data-light-spot-intensity]").property("value")),
          lightSpotPhi: parseFloat(d3.select("[data-light-spot-phi]").property("value")),
          lightSpotTheta: parseFloat(d3.select("[data-light-spot-theta]").property("value")),
          lightSpotDispersion: parseFloat(d3.select("[data-light-spot-dispersion]").property("value")),
        };
        head.setLighting(o);
        setLightingData();
      });

      d3.selectAll("[data-view-brightness],[data-view-contrast],[data-view-saturate],[data-view-blur]").on('input.command change.command keyup.command', function (ev) {
        const e = d3.select(this);
        let filters = [];
        d3.selectAll("[data-view-brightness],[data-view-contrast],[data-view-saturate],[data-view-blur]").nodes().forEach(node => {
          filters.push((node.dataset.viewBrightness || node.dataset.viewContrast || node.dataset.viewSaturate || node.dataset.viewBlur) + '(' + node.value + (node.dataset.viewBlur ? 'px' : '') + ')');
        });
        d3.select("#view").style("filter", filters.join(' '));
      });

      d3.selectAll("[data-voice-type]").on('click.command', function (ev) {
        const e = d3.select(this);
        d3.selectAll("[data-voice-type]").classed('selected', false);
        e.classed('selected', true);
        d3.select("#voice-google").style("display", (e.attr("data-voice-type") === 'google') ? "flex" : "none");
        d3.select("#voice-eleven").style("display", (e.attr("data-voice-type") === 'eleven') ? "flex" : "none");
        d3.select("#voice-microsoft").style("display", (e.attr("data-voice-type") === 'microsoft') ? "flex" : "none");
        d3.select("#lipsync").style("display", (e.attr("data-voice-type") !== 'microsoft') ? "flex" : "none");
        d3.select("#excludes").style("display", (e.attr("data-voice-type") === 'google') ? "flex" : "none");
      });

      d3.selectAll("[data-voice-google-id]").on('click.command', function (ev) {
        const e = d3.select(this);
        d3.selectAll("[data-voice-google-id]").classed('selected', false);
        e.classed('selected', true);
      });

      d3.selectAll("[data-voice-eleven-id]").on('click.command', function (ev) {
        const e = d3.select(this);
        d3.selectAll("[data-voice-eleven-id]").classed('selected', false);
        e.classed('selected', true);
      });

      d3.selectAll("[data-voice-microsoft-id]").on('click.command', function (ev) {
        const e = d3.select(this);
        d3.selectAll("[data-voice-microsoft-id]").classed('selected', false);
        e.classed('selected', true);
      });

      d3.selectAll("[data-voice-lipsync-lang]").on('click.command', function (ev) {
        const e = d3.select(this);
        d3.selectAll("[data-voice-lipsync-lang]").classed('selected', false);
        e.classed('selected', true);
        d3.select('#visemeword').dispatch('change');
      });

      d3.select("[data-voice-mixerbg]").on('input.command change.command keyup.command', function (ev) {
        let gain = parseFloat(d3.select("[data-voice-mixerbg]").property("value"));
        head.setMixerGain(null, gain);
      });

      d3.select("[data-voice-mixerspeech]").on('input.command change.command keyup.command', function (ev) {
        let gain = parseFloat(d3.select("[data-voice-mixerspeech]").property("value"));
        head.setMixerGain(gain, null);
      });

      d3.selectAll("[data-voice-reverb]").on('click.command', function (ev) {
        const e = d3.select(this);
        d3.selectAll("[data-voice-reverb]").classed('selected', false);
        e.classed('selected', true);
        let reverb = e.attr('data-voice-reverb');
        if (reverb === 'NONE') {
          head.setReverb(null);
        } else {
          head.setReverb(reverb);
        }
      });

      d3.selectAll("[data-voice-background]").on('click.command', async function (ev) {
        const e = d3.select(this);
        d3.selectAll("[data-voice-background]").classed("selected", false);
        let background = e.attr('data-voice-background');
        d3.selectAll("[data-voice-background='" + background + "']").classed("selected", true);
        if (background === 'NONE') {
          head.stopBackgroundAudio();
        } else if (background === 'FILE') {
          // Do nothing
        } else {
          head.playBackgroundAudio(background);
        }
      });

      // Whisper
      d3.selectAll("[data-whisper-type]").on('click.command', function (ev) {
        const e = d3.select(this);
        d3.selectAll("[data-whisper-type]").classed('selected', false);
        e.classed('selected', true);
      });

      // Dynamic bones
      d3.select("[data-dynamicbones-sensitivity]").on('input.command change.command keyup.command', function (ev) {
        let factor = parseFloat(d3.select("[data-dynamicbones-sensitivity]").property("value"));
        head.dynamicbones.setOptionValue("sensitivityFactor", factor);
      });

      d3.select("[data-dynamicbones-movement]").on('input.command change.command keyup.command', function (ev) {
        let factor = parseFloat(d3.select("[data-dynamicbones-movement]").property("value"));
        head.dynamicbones.setOptionValue("movementFactor", factor);
      });

      // Open voice background file
      d3.select("#voice-background-file").on('change', function (ev) {
        let file = ev.target.files[0];
        var reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = (ev2) => {
          let content = ev2.target.result;
          head.playBackgroundAudio(content);
        }
        ev.target.value = '';
      });

      d3.selectAll("[data-ai-model]").on('click.command', function (ev) {
        const e = d3.select(this);
        d3.selectAll("[data-ai-model]").classed('selected', false);
        e.classed('selected', true);
        d3.select("#ai-openai").style("display", (e.attr("data-ai-model").startsWith('gpt')) ? "flex" : "none");
        d3.select("#ai-gemini").style("display", (e.attr("data-ai-model").startsWith('gemini')) ? "flex" : "none");
        d3.select("#ai-grok").style("display", (e.attr("data-ai-model").startsWith('grok')) ? "flex" : "none");
        d3.select("#ai-llama").style("display", (e.attr("data-ai-model").startsWith('llama')) ? "flex" : "none");
      });

      d3.select("#session-duplicate").on('click', function (ev) {
        let id = CFG.sessions.length;
        let clone = JSON.parse(JSON.stringify(cfg()));
        clone.name = 'Nimetön';
        CFG.sessions.push(clone);
        saveConfig();
        loadConfig(id);
      });

      d3.select("#session-delete").on('click', function (ev) {
        if (CFG.sessions.length > 1) {
          let id = CFG.session;
          CFG.sessions.splice(id, 1);
          if (id > 0) id--;
          saveConfig();
          loadConfig(id);
        }
      });

      d3.select("#delete").on("click", function (ev) {
        d3.select("#selectall").classed("selected", false);
        d3.select(".session.selected").selectAll(".select.selected").nodes().forEach((n) => {
          d3.select(n.parentElement.parentElement).remove();
        });
      });

      d3.select("#flag").on("click", async function (ev) {
        let msgs = openaiBuildMessage();
        let flag = await openaiModerateMessage(msgs);
      });

      d3.select('#copy').on('click', function (ev) {
        const session = d3.select(".session.selected");
        const ms = [];

        ['ai-openai-system', 'ai-openai-user1', 'ai-openai-ai1',
          'ai-openai-user2', 'ai-openai-ai2'].forEach(x => {
            let p = cfg(x);
            if (p && p.length) ms.push(p);
          });

        session.selectAll(".message").nodes().forEach((d) => {
          let e = d3.select(d);
          let md = e.attr("data-input") || e.attr("data-output");
          ms.push(md);
        });

        const textarea = document.createElement('textarea');
        textarea.value = ms.join("\n\n");
        document.body.appendChild(textarea);
        textarea.select();
        document.execCommand('copy');
        document.body.removeChild(textarea);
      });

      d3.select(window).on('resize.updatesvg', function (ev) {
        d3.selectAll("textarea").dispatch("keyup");
      });

      d3.selectAll("#json").on("blur", function (ev) {
        let e = d3.select(this);
        const json = e.property("value");
        try {
          const c = JSON.parse(json);
          CFG.sessions[CFG.session] = c;
          saveConfig();
          loadConfig();
          i18nTranslate();
        } catch (error) {
          console.error(error);
        }
      });

      // Motion (experimental)
      d3.selectAll("#motion").on("click", function (ev) {
        const e = d3.select(this);
        const sel = e.classed("selected");
        e.classed("selected", !sel);
      });

      // Record
      d3.select('#record').on('click', async function (ev) {
        const x = d3.select(this);
        const mode = !x.classed("selected");
        x.classed("selected", mode);
        // recordingPlaySound();
        if (mode) {
          recordingRecord();
        } else {
          if (recordingMediaRecorder) {
            if (recordingMediaRecorder.state === 'recording') {
              recordingIgnoreData = true;
              recordingMediaRecorder.stop();
            }
            recordingMediaRecorder.stream.getTracks().forEach(track => track.stop());
            recordingMediaRecorder = null;
          }
          head.stopListening();
        }
      });

      // Viseme tester
      d3.select('#visemeword').on('input change keyup paste', function (ev) {
        const e = d3.select(this);
        const word = e.property("value");
        if (word) {
          try {
            const preprocessed = head.lipsyncPreProcessText(word, cfg('voice-lipsync-lang'));
            const visemes = head.lipsyncWordsToVisemes(preprocessed, cfg('voice-lipsync-lang'));
            d3.select('#visemedata').property("value", JSON.stringify(visemes)).dispatch("change");
          } catch (error) {
            d3.select('#visemedata').property("value", error).dispatch("change");
          }
        } else {
          d3.select('#visemedata').property("value", "").dispatch("change");
        }
      });



      try {

        // Get token
        jwt = await jwtGet();

        // Show last avatar
        let o = {};
        let name = cfg('avatar-name') || Object.values(site.avatars)[0].name;
        if (site.avatars.hasOwnProperty(name)) {
          o = site.avatars[name];
        } else if (name === 'URL') {
          o.url = cfg('avatar-url');
          o.body = cfg('avatar-body');
        } else {
          o = Object.values(site.avatars)[0];
        }
        await head.showAvatar(o, progressUpdate);
        headLoaded(true);
      } catch (error) {
        errorShow(error);

        // Backup plan: show the first avatar in site config
        await head.showAvatar(Object.values(site.avatars)[0], progressUpdate);
        headLoaded(true);
      }

    });

  </script>
</head>

<body class="theme-dark">

  <div id="main" class="ratio-wide layout-land presence-video">

    <div id="left" class="noselect nodrag">
      <div id="avatar"></div>

      <div class="border starttransparent"></div>

      <div id="loading">
        <div id="loading-back"></div>
        <div id="loading-top"></div>
        <div id="loading-value"></div>
      </div>

    </div>






  </div>

</body>

</html>